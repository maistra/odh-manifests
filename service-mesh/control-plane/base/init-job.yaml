apiVersion: batch/v1
kind: Job
metadata:
  name: odh-ossm-init-job
spec:
  template:
    spec:
      containers:
      - name: odh-ossm-init-job
        image: quay.io/openshift/origin-cli
        command: ["/bin/bash", "-c", "--"]
        args:
          - |
            mkdir /tmp/bin

            # install yq for yaml parsing.
            curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /tmp/bin/yq  && chmod +x /tmp/bin/yq 

            # install jq for json parsing. 
            curl -L https://github.com/jqlang/jq/releases/download/jq-1.6/jq-linux64 -o /tmp/bin/jq  && chmod +x /tmp/bin/jq 

            # install envsubst 
            curl -L https://github.com/a8m/envsubst/releases/download/v1.2.0/envsubst-`uname -s`-`uname -m` -o /tmp/bin/envsubst && chmod +x /tmp/bin/envsubst
            export PATH=/tmp/bin:$PATH

            export ISTIO_NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
            export ODH_NAMESPACE=$(kubectl get configmap --all-namespaces -o json | jq -r '.items[] | select(.metadata.name == "odh-common-config") | .metadata.namespace')

            export CLIENT_SECRET=$(openssl rand -hex 32)
            export HMAC_SECRET=$(openssl rand -hex 32)
            export DOMAIN=$(kubectl get ingress.config.openshift.io cluster -o 'jsonpath={.spec.domain}')
            endpoint=$(curl https://kubernetes.default.svc/.well-known/oauth-authorization-server -sS -k)
            export TOKEN_ENDPOINT=$(echo $endpoint | jq .token_endpoint)
            export AUTH_ENDPOINT=$(echo $endpoint | jq .authorization_endpoint)
            issuer=$(echo $endpoint | jq -r '.issuer')
            export OAUTH_PORT=$(echo $issuer | sed -n 's/.*:\([0-9]\+\)$/\1/p')
            OAUTH_PORT=${OAUTH_PORT:-443}
            export TOKEN_FILEPATH="/etc/cluster-resources/token-secret.yaml"
            export OAUTH_ROUTE=$(echo $issuer | sed 's/^https\?:\/\/\([^:\/]*\).*$/\1/')
            export HMAC_FILEPATH="/etc/cluster-resources/hmac-secret.yaml"

            apply_yaml() {
              filename="$1"

              # Skip these secret files, they are used elsewhere.
              skip_files=("$TOKEN_FILEPATH" "$HMAC_FILEPATH")
              [[ " ${skip_files[*]} " =~ " ${filename} " ]] && return 0

              case "$filename" in
                "/etc/cluster-resources/authconfig.yaml" | "/etc/cluster-resources/00_smm.yaml")
                  namespace="${ODH_NAMESPACE}"
                  ;;
                *)
                  namespace="${ISTIO_NAMESPACE}"
                  ;;
              esac
              
              if [[ "${filename}" =~ \.patch\.yaml$ ]]; then
                kind_name=$(cat "${filename}" | envsubst | yq eval '.kind, .metadata.name' | awk '{ printf("%s/", tolower($0)) }' | sed 's/\/$//')
                kubectl patch $kind_name -n $namespace --type=merge -p "$(cat "${filename}" | envsubst)"
              else
                cat "${filename}" | envsubst | kubectl apply -n $namespace -f -
              fi
            }

            route_name="odh-dashboard"
            while ! kubectl get route "${route_name}" -n "${ODH_NAMESPACE}" >/dev/null 2>&1; do
                echo "Waiting for the ${route_name} Route resource to be created..."
                sleep 5
            done

            kubectl delete route "${route_name}" -n "${ODH_NAMESPACE}"

            # recreate secrets for oauth2
            kubectl delete secret istio-odh-oauth2 -n ${ISTIO_NAMESPACE} --ignore-not-found
            kubectl create secret generic istio-odh-oauth2 -n ${ISTIO_NAMESPACE} \
                --from-file=token-secret.yaml=<(envsubst < $TOKEN_FILEPATH) \
                --from-file=hmac-secret.yaml=<(envsubst < $HMAC_FILEPATH)

            # add annotation to the root namespace (hardcoded pre-plugin)
            kubectl annotate namespace ${ODH_NAMESPACE} opendatahub.io/service-mesh=true

            export SMCP_NAME=$(kubectl get smcp -n ${ISTIO_NAMESPACE} -o name | head -n 1 | awk -F '/' '{ print $NF }')
            
            echo "waiting for smcp/${SMCP_NAME} to be ready"
            kubectl -n ${ISTIO_NAMESPACE} wait --for=condition=Ready smcp/${SMCP_NAME} --timeout=180s          

            # iterate over all files in the subdirectory
            for filename in /etc/cluster-resources/*
            do
              apply_yaml "$filename"
            done

            # Ensure secrets are mounted in ingress-gateway. If not, restart the pod.
            kubectl wait pods -l app=istio-ingressgateway --for condition=ready -n ${ISTIO_NAMESPACE}

            INGRESS_POD=$(kubectl get pods -n ${ISTIO_NAMESPACE} -l app=istio-ingressgateway -o jsonpath='{.items[0].metadata.name}')
            EXEC_OUTPUT=$(kubectl exec $INGRESS_POD -n ${ISTIO_NAMESPACE} -c istio-proxy -- ls -al /etc/istio/odh-oauth2/{token-secret.yaml,hmac-secret.yaml} 2>&1)
            EXEC_EXIT_STATUS=$?

            if echo $EXEC_OUTPUT | grep -q 'No such file or directory'; then
              # If we don't see the secrets mounted, restart deployment.
              kubectl rollout restart deployment -n ${ISTIO_NAMESPACE} istio-ingressgateway
            elif [[ $EXEC_EXIT_STATUS -ne 0 ]]; then
              echo "Failed with: $EXEC_OUTPUT"
              exit 1
            fi

            exit 0
            
        volumeMounts:
          - name: config-volume
            mountPath: /etc/cluster-resources
      volumes:
      - name: config-volume
        configMap:
          name: cluster-resources
      restartPolicy: Never
      serviceAccountName: init-job-executor
apiVersion: batch/v1
kind: Job
metadata:
  name: odh-ossm-init-job
spec:
  template:
    spec:
      containers:
      - name: odh-ossm-init-job
        image: quay.io/openshift/origin-cli
        command: ["/bin/bash", "-c", "--"]
        args:
          - |
            mkdir /tmp/bin

            # install jq for json parsing. 
            curl -L https://github.com/jqlang/jq/releases/download/jq-1.6/jq-linux64  -o /tmp/bin/jq  && chmod +x /tmp/bin/jq 

            # install envsubst 
            curl -L https://github.com/a8m/envsubst/releases/download/v1.2.0/envsubst-`uname -s`-`uname -m` -o /tmp/bin/envsubst && chmod +x /tmp/bin/envsubst
            export PATH=/tmp/bin:$PATH

            export ISTIO_NAMESPACE=$(kubectl get jobs -o jsonpath='{.items[?(@.metadata.name=="odh-ossm-init-job")].metadata.namespace}')
            export ODH_NAMESPACE=$(kubectl get configmap --all-namespaces -o json | jq -r '.items[] | select(.metadata.name == "odh-common-config") | .metadata.namespace')

            export CLIENT_SECRET=$(openssl rand -hex 32)
            export HMAC_SECRET=$(openssl rand -hex 32)
            export DOMAIN=$(kubectl get ingress.config.openshift.io cluster -o 'jsonpath={.spec.domain}')
            endpoint=$(curl https://kubernetes.default.svc/.well-known/oauth-authorization-server -sS -k)
            export TOKEN_ENDPOINT=$(echo $endpoint | jq .token_endpoint)
            export AUTH_ENDPOINT=$(echo $endpoint | jq .authorization_endpoint)
            export OAUTH_ROUTE=$(echo $endpoint | jq .issuer | sed 's/"//g; s/https:\/\///g') # remove quotes and https
            export TOKEN_FILEPATH="/etc/cluster-resources/token-secret.yaml"
            export HMAC_FILEPATH="/etc/cluster-resources/hmac-secret.yaml"

            apply_yaml() {
              filename="$1"

              # Skip these secret files, they are used elsewhere.
              skip_files=("$TOKEN_FILEPATH" "$HMAC_FILEPATH")
              [[ " ${skip_files[*]} " =~ " ${filename} " ]] && return 0

              case "$filename" in
                "/etc/cluster-resources/authconfig.yaml")
                  namespace="${ODH_NAMESPACE}"
                  ;;
                *)
                  namespace="${ISTIO_NAMESPACE}"
                  ;;
              esac

              cat "$filename" | envsubst | kubectl apply -n $namespace -f -
            }

            # recreate secrets for oauth2
            kubectl delete secret istio-odh-oauth2 -n ${ISTIO_NAMESPACE} --ignore-not-found
            kubectl create secret generic istio-odh-oauth2 -n ${ISTIO_NAMESPACE} \
                --from-file=token-secret.yaml=<(envsubst < $TOKEN_FILEPATH) \
                --from-file=hmac-secret.yaml=<(envsubst < $HMAC_FILEPATH)

            # add annotation to the root namespace (hardcoded pre-plugin)
            kubectl annotate namespace ${ODH_NAMESPACE} opendatahub.io/service-mesh=true

            # wait for app to be ready
            echo "waiting for SMCP to be ready"
            kubectl -n ${ISTIO_NAMESPACE} wait --for=condition=Ready smcp/basic --timeout=180s          

            # iterate over all files in the subdirectory
            for filename in /etc/cluster-resources/*
            do
              apply_yaml "$filename"
            done

            # Ensure secrets are mounted in ingress-gateway. If not, restart the pod.
            kubectl wait pods -l app=istio-ingressgateway --for condition=ready -n ${ISTIO_NAMESPACE}

            INGRESS_POD=$(kubectl get pods -n ${ISTIO_NAMESPACE} -l app=istio-ingressgateway -o jsonpath='{.items[0].metadata.name}')
            EXEC_OUTPUT=$(kubectl exec $INGRESS_POD -n ${ISTIO_NAMESPACE} -c istio-proxy -- ls -al /etc/istio/odh-oauth2/{token-secret.yaml,hmac-secret.yaml} 2>&1)
            EXEC_EXIT_STATUS=$?

            if echo $EXEC_OUTPUT | grep -q 'No such file or directory'; then
              # If we don't see the secrets mounted, restart deployment.
              kubectl rollout restart deployment -n ${ISTIO_NAMESPACE} istio-ingressgateway
            elif [[ $EXEC_EXIT_STATUS -ne 0 ]]; then
              echo "Failed with: $EXEC_OUTPUT"
              exit 1
            fi

            exit 0
            
        volumeMounts:
          - name: config-volume
            mountPath: /etc/cluster-resources
      volumes:
      - name: config-volume
        configMap:
          name: cluster-resources
      restartPolicy: Never
      serviceAccountName: init-job-executor